package templates

// RepositoryFileGo ...
var RepositoryFileGo = `// Code generated by {{ .Generator }} {{ .Version }} ({{ .Build }}); DO NOT EDIT
package repository

import (
	"errors"
	"sync"
)

type fileRepository struct {
	err   error
	path  string
	mutex sync.Mutex
}

func (r *fileRepository) Add(id string, value interface{}) {
	r.mutex.Lock()
	defer r.mutex.Unlock()
	data, err := DecodeFile(r.path)
	if err != nil {
		data = map[string]interface{}{}
	}
	data[id] = value
	if err := EncodeFile(r.path, data); err != nil {
		r.err = err
		return
	}
}

func (r *fileRepository) Error() error {
	return r.err
}

func (r *fileRepository) FindByID(id string) (item interface{}) {
	r.mutex.Lock()
	defer r.mutex.Unlock()
	data, err := DecodeFile(r.path)
	if err != nil {
		r.err = err
		return
	}
	item, exists := data[id]
	if !exists {
		r.err = errors.New("item does not exist")
		return
	}
	return item
}

func (r *fileRepository) FindByKeyValue(key string, val interface{}) (item interface{}) {
	r.mutex.Lock()
	defer r.mutex.Unlock()
	data, err := DecodeFile(r.path)
	if err != nil {
		r.err = err
		return
	}
	for _, item := range data {
		switch t := item.(type) {
		case map[string]interface{}:
			for k, v := range t {
				if key == k && v == val {
					return item
				}
			}
		default:
			continue
		}
	}
	r.err = errors.New("item does not exist")
	return item
}

func (r *fileRepository) Remove(id string) {
	r.mutex.Lock()
	defer r.mutex.Unlock()
	data, err := DecodeFile(r.path)
	if err != nil {
		r.err = err
		return
	}
	delete(data, id)
	if err := EncodeFile(r.path, data); err != nil {
		r.err = err
		return
	}
}

// NewFileRepository ...
func NewFileRepository(path string) Repository {
	return &fileRepository{
		path: path,
	}
}
`
